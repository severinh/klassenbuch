/*
 * Klassenbuch
 * Copyright (C) 2006 - 2008 Severin Heiniger
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * To view the GNU General Public License visit
 * http://www.gnu.org/copyleft/gpl.html
 * or write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
*/

/**
 * @class The base class for a bunch of controls such as <em>Controls.Table</em> and <em>Controls.Button</em>.
 * It provides various wrapper methods such as <em>show</em> and <em>setStyle</em>, which makes it possible to modify the
 * control's appeareance and fire events.
 * @param {HTMLObject|String} element The DOM element or its ID to convert to a Control instance.
 * @augments Observable
 */
var Control = Class.create(/** @scope Control.Prototype */ {
	initialize: function(element) {
		/**
		 * @field {ExtendedHTMLObject} The control's DOM element.
		*/
		this.element = $(element);
		
		/**
		 * @field {String} The ID, generated by Prototype.
		*/
		this.id = this.element.identify();
		
		/**
		 * @field {Control[]} Control instances located within the control. They can be added using the method
		 * <em>registerChildControl</em>.
		*/
		this._childControls = [];
		
		/**
		 * @field {Object} A map of shortcut handler functions. New shortcut handlers can be added using the method
		 * <em>registerShortcut</em>.
		*/
		this._shortcuts = {};
	},
	
	/**
	 * @method Utility function that adds additional options to the <em>options</em> property. Default options can be
	 * passed to the method along with actual options, which will overwrite existing default values.
	 * @param {Object|null} standardValues The default values to use.
	 * @param {Object|null} options The actual options.
	*/
	setOptions: function(standardValues, options) {
		this.options = Object.extend(this.options || {}, Object.extend(standardValues || {}, options || {}));
	},
	
	/**
	 * @method Controls may have child controls. To make sure they are removed properly when the parent control is removed,
	 * they need to be registered using this method.
	 * @param {Control} The child controls. Multiple controls can be passed to this method.
	*/
	registerChildControl: function() {
		$A(arguments).each(function(control) {
			this._childControls.push(control);
		}, this);
	},
	
	/**
	 * @method Another method to avoid redundancy in Control based classes: If an event handler is added to any observable object
	 * from within a control, it needs to be removed properly, as soon the control is removed. This method automagically
	 * takes care of this cleanup task.
	 * @param {Observable} observableObject The object to observe.
	 * @param {String} eventName The name of the specific event to observe.
	 * @param {Function} handler The event handler function.
	 * @param {Object} [scope] The scope in which the handler is to be executed.
	 * @return {Function} The event handler function.
	*/
	_onExternalEvent: function(observableObject, eventName, handler, scope) {
		handler = observableObject.on(eventName, handler, scope);
		
		this.on("remove", function() {
			observableObject.un(eventName, handler);
		});
		
		return handler;
	},
	
	/**
	 * @method Connects a list of keys to a handler function that is executed, as soon as the user presses one of the keys.
	 * @param {Number[]|Number} keys A list of numeric key codes. Can be a single non-array key code as well. A textual
	 * list of key codes is included in Prototype's Event namespace. This method automatically enables the shortcut
	 * detection.
	 * @param {Object} handler The shortcut handler function.
	 * @param {Object} [scope] The scope in which the handler is to be executed.
	*/
	registerShortcut: function(keys, handler, scope) {
		handler = handler.bind(scope);
		
		$A(keys).each(function(key) {
			this._shortcuts[key] = handler;
		}, this);
		
		this.enableShortcuts();
	},
	
	/**
	 * @method Enables the detection of shortcuts pressed by the user.
	*/
	enableShortcuts: function() {
		if (!this._shortCutObserver) { // The keydown event should'nt be observed twice.
			this._shortCutObserver = (function(event) {
				if (this._shortcutsEnabled) {
					var handler = this._shortcuts[event.keyCode];
					
					if (handler) {
						handler();
					}
				}
			}).bindAsEventListener(this);
			
			document.observe("keydown", this._shortCutObserver);
		}
		
		this._shortcutsEnabled = true;
	},
	
	/**
	 * @method Disables the detection of shortcuts pressed by the user.
	*/
	disableShortcuts: function() {
		this._shortcutsEnabled = false;
	},
	
	/**
     * @method Hides the control in case it's visible and fires the events "beforehide" and "hide". The first one can be
     * used to prevent the control from being hidden.
     * @return {Control} Returns itself for chaining purposes.
    */
	hide: function() {
		if (this.visible() && this.fireEvent("beforehide")) {
			this.element.hide();
			this.fireEvent("hide");
		}
		
		return this;
	},
	
	/**
     * @method Show the control in case it's hidden and fires the events "beforeshow" and "show". The first one can be
     * used to prevent the control from being shown.
     * @return {Control} Returns itself for chaining purposes.
    */
	show: function() {
		if (!this.visible() && this.fireEvent("beforeshow")) {
			this.element.show();
			this.fireEvent("show");
		}
		
		return this;
	},
	
	/**
     * @method Removes the control from the webpage in case this hasn't happened yet and fires the events "beforeremove"
     * "remove" and "afterremove". The first one can be used to prevent the control from being removed.
     * @return {Control} Returns itself for chaining purposes.
    */
	remove: function() {
        if (this.element && this.fireEvent("beforeremove")) {
			// Need to fire this first as event handlers might still need this.element
			this.fireEvent("remove");
			
			// Do all the cleanup stuff
			this._childControls.invoke("remove");
			
			if (this._shortCutObserver) {
				document.stopObserving("keydown", this._shortCutObserver);
			}
			
			this.element.stopObserving();
			
			if (this.element.parentNode) { // In case the control was never added to the DOM
				this.element.remove();
			}
			
			delete this.element;
			this.fireEvent("afterremove");
			
			this.clearAllListeners();
		}
		
		return this;
	},
	
	/**
     * @method Shows the control if it's hidden and vice versa (wrapper method).
     * @return {Control} Returns itself for chaining purposes.
	*/
	toggle: function() {
		return this[this.visible() ? "hide" : "show"]();
	}
}).addMethods(Observable);

$w("setStyle addClassName removeClassName toggleClassName centerOnScreen").each(function(a) {
	Control.prototype[a] = function(val) {
		this.element[a](val);
		return this;
	};
});

$w("select hasClassName getStyle getClassNames getHeight getWidth visible getDimensions").each(function(a) {
	Control.prototype[a] = function(val) {
		return this.element[a](val);
	};
});

/**
 * A namespace containing a bunch of controls based on the Control class.
*/
var Controls = {};